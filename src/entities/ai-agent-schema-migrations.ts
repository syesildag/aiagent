/**
 * Aiagentschemamigrations.ts.ts
 *
 * Entity class generated from PostgreSQL table: Entity class generated from PostgreSQL table: public.ai_agent_schema_migrations.AiAgentSchemaMigrations.ts
 *
 * Auto-generated on 2025-10-11
 * Do not edit this file manually.
 */

import { AbstractRepository, Entity } from "../repository/abstractRepository";
import { Column } from "../repository/annotations/Column";
import { Find } from "../repository/annotations/find";
import { Id } from "../repository/annotations/Id";
import { OneToOne } from "../repository/annotations/OneToOne";
import { OneToMany } from "../repository/annotations/OneToMany";
import { ManyToOne } from "../repository/annotations/ManyToOne";
import { repository } from "../repository/repository";
import { queryDatabase } from "../utils/pgClient";
export class AiAgentSchemaMigrations extends Entity<string> {

   private version: string;
   private appliedAt?: Date;
   private description?: string;

   constructor({ version, appliedAt, description }: { version: string, appliedAt?: Date, description?: string }) {
      super();
      this.version = version;
      this.appliedAt = appliedAt;
      this.description = description;
   }

   @Id('version')
   public getId(): string {
      return this.version;
   }

   public getVersion(): string {
      return this.version;
   }

   @Column({ columnName: 'applied_at', notNull: true, hasDefault: true })
   public getAppliedAt(): Date | undefined {
      return this.appliedAt;
   }

   @Column({ columnName: 'description' })
   public getDescription(): string | undefined {
      return this.description;
   }

   public setAppliedAt(appliedAt?: Date) {
      this.appliedAt = appliedAt;
   }

   public setDescription(description?: string) {
      this.description = description;
   }

}

class AiAgentSchemaMigrationsRepository extends AbstractRepository<AiAgentSchemaMigrations> {

   constructor() {
      super('ai_agent_schema_migrations', AiAgentSchemaMigrations);
   }

   /**
    * Find migration by version (string-based ID)
    */
   public async findByVersion(version: string): Promise<AiAgentSchemaMigrations | null> {
      const rows = await queryDatabase(
         'SELECT version, applied_at, description FROM ai_agent_schema_migrations WHERE version = $1',
         [version]
      );
      
      if (rows.length === 0) {
         return null;
      }
      
      const row = rows[0];
      return new AiAgentSchemaMigrations({
         version: row.version,
         appliedAt: row.applied_at,
         description: row.description
      });
   }

   /**
    * Get all applied migrations ordered by version
    */
   public async findAllApplied(): Promise<AiAgentSchemaMigrations[]> {
      const rows = await queryDatabase(
         'SELECT version, applied_at, description FROM ai_agent_schema_migrations ORDER BY version ASC'
      );
      
      return rows.map((row: any) => new AiAgentSchemaMigrations({
         version: row.version,
         appliedAt: row.applied_at,
         description: row.description
      }));
   }

   /**
    * Insert a new migration record
    */
   public async insertMigration(version: string, description: string): Promise<AiAgentSchemaMigrations> {
      const appliedAt = new Date();
      
      await queryDatabase(
         'INSERT INTO ai_agent_schema_migrations (version, applied_at, description) VALUES ($1, $2, $3)',
         [version, appliedAt, description]
      );
      
      return new AiAgentSchemaMigrations({
         version,
         appliedAt,
         description
      });
   }

   /**
    * Check if a migration version exists
    */
   public async exists(version: string): Promise<boolean> {
      const migration = await this.findByVersion(version);
      return migration !== null;
   }

}

const aiagentschemamigrationsRepository = new AiAgentSchemaMigrationsRepository();

repository.set(AiAgentSchemaMigrations, aiagentschemamigrationsRepository);

export default aiagentschemamigrationsRepository;
