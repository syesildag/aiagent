import { ColumnInfo, RelationshipInfo, TableInfo } from './dbMetadataExtractor.js';

export interface FieldInfo {
  name: string;
  type: string;
  isOptional: boolean;
  columnName: string;
  isPrimaryKey: boolean;
  isNotNull: boolean;
  isUnique: boolean;
}

export interface EntityGenerationOptions {
  includeImports: boolean;
  includeConstructor: boolean;
  includeGettersSetters: boolean;
  includeToString: boolean;
  includeValidation: boolean;
  baseClass?: string;
}

/**
 * TypeScript Entity Code Generator (Session.ts pattern)
 * 
 * This class generates TypeScript entity classes following the exact pattern of session.ts
 */
export class CodeGenerationUtils {
  static generateFileHeader(tableName: string, schemaName: string = 'public'): string {
    const className = this.toPascalCase(tableName);
    return `/**
 * ${className}.ts
 *
 * Entity class generated from PostgreSQL table: ${schemaName}.${tableName}
 *
 * Auto-generated on ${new Date().toISOString().split('T')[0]}
 * Do not edit this file manually.
 */

`;
  }

  static formatTypeScriptCode(code: string): string {
    // Basic formatting - replace multiple empty lines with single
    return code.replace(/\n\n\n+/g, '\n\n').trim() + '\n';
  }

  static toPascalCase(str: string): string {
    return str
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }
}

export class TypeScriptCodeGenerator {

  constructor() {
  }

  getDefaultOptions(): EntityGenerationOptions {
    return {
      includeImports: true,
      includeConstructor: true,
      includeGettersSetters: true,
      includeToString: true,
      includeValidation: false
    };
  }

  /**
   * Generate complete TypeScript entity class from table metadata following session.ts pattern
   */
  generateEntityClass(
    tableInfo: TableInfo,
    relationships: RelationshipInfo[],
    options: EntityGenerationOptions = this.getDefaultOptions(),
    outputPath?: string
  ): string {
    const className = this.toPascalCase(tableInfo.tableName);
    const fields = this.generateFieldsFromColumns(tableInfo.columns);
    
    const parts: string[] = [];

    // Imports
    parts.push(this.generateImports(outputPath));

    // Class declaration
    parts.push(`export class ${className} extends Entity {`);
    parts.push('');

    // Private fields
    for (const field of fields) {
      const optionalSuffix = field.isOptional ? '?' : '';
      parts.push(`   private ${field.name}${optionalSuffix}: ${field.type};`);
    }
    parts.push('');

    // Constructor
    const constructorLines = this.generateConstructor(className, fields);
    for (const line of constructorLines) {
      parts.push(line.length > 0 ? `   ${line}` : '');
    }
    parts.push('');

    // Getter methods with annotations
    for (const field of fields) {
      const getterLines = this.generateAnnotatedGetter(field);
      for (const line of getterLines) {
        parts.push(line.length > 0 ? `   ${line}` : '');
      }
      parts.push('');
    }

    // Setter methods for nullable fields
    for (const field of fields) {
      if (field.isOptional && field.name !== 'id') {
        const setterLines = this.generateSetter(field);
        for (const line of setterLines) {
          parts.push(line.length > 0 ? `   ${line}` : '');
        }
        parts.push('');
      }
    }

    parts.push('}');
    parts.push('');

    // Repository class
    const repositoryLines = this.generateRepository(className, tableInfo.tableName);
    parts.push(...repositoryLines);

    return parts.join('\n');
  }



  private generateImports(outputPath?: string): string {
    // Calculate relative paths based on output directory
    const relativePath = this.calculateRelativeImportPath(outputPath);
    
    return `import { AbstractRepository, Entity } from "${relativePath}abstractRepository";
import { Column } from "${relativePath}annotations/Column";
import { Find } from "${relativePath}annotations/find";
import { Id } from "${relativePath}annotations/Id";
import { repository } from "${relativePath}repository";`;
  }

  /**
   * Calculate the correct relative import path based on output directory
   */
  private calculateRelativeImportPath(outputPath?: string): string {
    if (!outputPath) {
      // Default path for src/repository/entities/
      return "../";
    }

    // Normalize the output path and remove leading/trailing slashes
    let normalizedOutput = outputPath.replace(/\\/g, '/').replace(/^\/+|\/+$/g, '');
    
    // If it's an absolute path, extract only the relative part from current working directory
    // Look for common project markers like "aiagent" or get the relative part after the last known directory
    if (normalizedOutput.includes('/')) {
      // Extract relative path from project root
      const projectMarkers = ['aiagent', 'Workspace/aiagent'];
      for (const marker of projectMarkers) {
        const markerIndex = normalizedOutput.indexOf(marker);
        if (markerIndex !== -1) {
          // Get everything after the project marker + "/"
          const afterMarker = normalizedOutput.substring(markerIndex + marker.length + 1);
          if (afterMarker) {
            normalizedOutput = afterMarker;
            break;
          }
        }
      }
    }
    
    // Determine the path from output directory to src/repository/
    // Common patterns:
    // src/repository/entities -> ../
    // src/entities -> ../repository/
    // generated -> ../src/repository/
    // entities -> ../src/repository/
    // nested/path/deep -> ../../../src/repository/
    
    if (normalizedOutput.includes('src/repository/entities')) {
      return "../";
    } else if (normalizedOutput.includes('src/entities')) {
      return "../repository/";
    } else if (normalizedOutput.includes('src/repository')) {
      // If directly in src/repository, imports would be ./
      return "./";
    } else if (normalizedOutput.includes('src/')) {
      // If inside src but not in repository, go up to src then into repository
      const srcIndex = normalizedOutput.lastIndexOf('src/');
      const pathAfterSrc = normalizedOutput.substring(srcIndex + 4);
      const depth = pathAfterSrc.split('/').filter(p => p.length > 0).length;
      const upLevels = '../'.repeat(depth);
      return `${upLevels}repository/`;
    } else {
      // Outside src directory, need to go to src/repository/
      // Count the directory depth to determine how many ../ are needed
      const pathParts = normalizedOutput.split('/').filter(p => p.length > 0 && p !== '.');
      const depth = pathParts.length;
      
      // Go up the number of levels equal to the depth, then into src/repository
      const upLevels = '../'.repeat(depth);
      return `${upLevels}src/repository/`;
    }
  }

  private generateFieldsFromColumns(columns: ColumnInfo[]): FieldInfo[] {
    return columns.map(col => ({
      name: this.toCamelCase(col.name),
      type: this.mapDatabaseTypeToTypeScript(col),
      isOptional: col.isNullable || col.name === 'id' || col.hasDefault,
      columnName: col.name,
      isPrimaryKey: col.isPrimary,
      isNotNull: !col.isNullable,
      isUnique: false // We'll handle this separately if needed
    }));
  }

  private generateConstructor(className: string, fields: FieldInfo[]): string[] {
    const lines: string[] = [];
    
    // Build constructor parameter with object destructuring like session.ts
    const destructureParams: string[] = [];
    const typeParams: string[] = [];
    
    for (const field of fields) {
      // For destructuring: just the field name (no optional marker)
      destructureParams.push(field.name);
      
      // For type definition: include optional marker
      const optionalSuffix = field.isOptional ? '?' : '';
      typeParams.push(`${field.name}${optionalSuffix}: ${field.type}`);
    }
    
    const paramString = `{ ${destructureParams.join(', ')} }: { ${typeParams.join(', ')} }`;
    lines.push(`constructor(${paramString}) {`);
    lines.push('   super();');
    
    // Assign all fields
    for (const field of fields) {
      lines.push(`   this.${field.name} = ${field.name};`);
    }
    
    lines.push('}');

    return lines;
  }

  private generateAnnotatedGetter(field: FieldInfo): string[] {
    const lines: string[] = [];
    const capitalizedName = this.toPascalCase(field.name);
    const returnType = field.isOptional ? `${field.type} | undefined` : field.type;
    
    if (field.isPrimaryKey) {
      lines.push(`@Id('${field.columnName}')`);
    } else {
      const columnOptions: string[] = [];
      columnOptions.push(`columnName: '${field.columnName}'`);
      if (field.isNotNull) {
        columnOptions.push('notNull: true');
      }
      if (field.isUnique) {
        columnOptions.push('unique: true');
      }
      
      lines.push(`@Column({ ${columnOptions.join(', ')} })`);
    }
    
    lines.push(`public get${capitalizedName}(): ${returnType} {`);
    lines.push(`   return this.${field.name};`);
    lines.push('}');
    
    return lines;
  }

  private generateSetter(field: FieldInfo): string[] {
    const lines: string[] = [];
    const capitalizedName = this.toPascalCase(field.name);
    
    lines.push(`public set${capitalizedName}(${field.name}${field.isOptional ? '?' : ''}: ${field.type}) {`);
    lines.push(`   this.${field.name} = ${field.name};`);
    lines.push('}');
    
    return lines;
  }

  private generateRepository(className: string, tableName: string): string[] {
    const lines: string[] = [];
    
    lines.push(`export class ${className}Repository extends AbstractRepository<${className}> {`);
    lines.push('');
    lines.push('   constructor() {');
    lines.push(`      super('${tableName}', ${className});`);
    lines.push('   }');
    lines.push('');
    lines.push('   @Find()');
    lines.push(`   public async findByUserLogin(userLogin: string): Promise<${className} | null> {`);
    lines.push('      return null;');
    lines.push('   }');
    lines.push('}');
    lines.push('');
    lines.push(`const ${this.toCamelCase(className)}Repository = new ${className}Repository();`);
    lines.push('');
    lines.push(`repository.set(${className}, ${this.toCamelCase(className)}Repository);`);
    lines.push('');
    lines.push(`export default ${this.toCamelCase(className)}Repository;`);
    
    return lines;
  }

  /**
   * Map database column type to TypeScript type
   */
  mapDatabaseTypeToTypeScript(column: ColumnInfo): string {
    // Remove array notation for mapping
    const baseType = column.dataType.replace('[]', '');
    const isArray = column.dataType.includes('[]');

    let tsType: string;

    // Map PostgreSQL types to TypeScript types
    switch (baseType.toLowerCase()) {
      case 'integer':
      case 'int':
      case 'int4':
      case 'smallint':
      case 'bigint':
      case 'int8':
      case 'serial':
      case 'bigserial':
      case 'numeric':
      case 'decimal':
      case 'real':
      case 'double precision':
      case 'float4':
      case 'float8':
        tsType = 'number';
        break;

      case 'character varying':
      case 'varchar':
      case 'character':
      case 'char':
      case 'text':
      case 'uuid':
        tsType = 'string';
        break;

      case 'boolean':
      case 'bool':
        tsType = 'boolean';
        break;

      case 'timestamp without time zone':
      case 'timestamp with time zone':
      case 'timestamp':
      case 'timestamptz':
      case 'date':
      case 'time':
      case 'timetz':
        tsType = 'Date';
        break;

      case 'json':
      case 'jsonb':
        tsType = 'any';
        break;

      case 'bytea':
        tsType = 'Buffer';
        break;

      default:
        tsType = 'any';
        break;
    }

    return isArray ? `${tsType}[]` : tsType;
  }

  toPascalCase(str: string): string {
    return str
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  toCamelCase(str: string): string {
    const pascal = this.toPascalCase(str);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
  }

  toKebabCase(str: string): string {
    return str
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .toLowerCase();
  }
}