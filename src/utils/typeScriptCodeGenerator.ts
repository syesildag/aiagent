import { ColumnInfo, RelationshipInfo, TableInfo } from './dbMetadataExtractor.js';

export interface FieldInfo {
  name: string;
  type: string;
  isOptional: boolean;
  columnName: string;
  isPrimaryKey: boolean;
  isNotNull: boolean;
  isUnique: boolean;
  hasDefault: boolean;
}

export interface EntityGenerationOptions {
  includeImports: boolean;
  includeConstructor: boolean;
  includeGettersSetters: boolean;
  includeToString: boolean;
  includeValidation: boolean;
  generateRepository?: boolean;
  baseClass?: string;
  uniqueColumns?: string[];
}

/**
 * TypeScript Entity Code Generator (Session.ts pattern)
 * 
 * This class generates TypeScript entity classes following the exact pattern of session.ts
 */
export class CodeGenerationUtils {
  static generateFileHeader(tableName: string, schemaName: string = 'public'): string {
    const className = this.toPascalCase(tableName);
    return `/**
 * ${className}.ts
 *
 * Entity class generated from PostgreSQL table: ${schemaName}.${tableName}
 *
 * Auto-generated on ${new Date().toISOString().split('T')[0]}
 * Do not edit this file manually.
 */

`;
  }

  static formatTypeScriptCode(code: string): string {
    // Basic formatting - replace multiple empty lines with single
    return code.replace(/\n\n\n+/g, '\n\n').trim() + '\n';
  }

  static toPascalCase(str: string): string {
    return str
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }
}

export class TypeScriptCodeGenerator {

  constructor() {
  }

  getDefaultOptions(): EntityGenerationOptions {
    return {
      includeImports: true,
      includeConstructor: true,
      includeGettersSetters: true,
      includeToString: true,
      includeValidation: false
    };
  }

  /**
   * Generate complete TypeScript entity class from table metadata following session.ts pattern
   */
  generateEntityClass(
    tableInfo: TableInfo,
    relationships: RelationshipInfo[],
    options: EntityGenerationOptions = this.getDefaultOptions(),
    outputPath?: string
  ): string {
    const className = this.toPascalCase(tableInfo.tableName);
    const uniqueColumnNames = options.uniqueColumns || [];
    const fields = this.generateFieldsFromColumns(tableInfo.columns, uniqueColumnNames);
    const relationshipFields = this.generateRelationshipFields(relationships);
    
    const parts: string[] = [];

    // Imports
    parts.push(this.generateImports(outputPath));
    
    // Add imports for related entities
    const entityImports = this.generateEntityImports(relationships, outputPath);
    if (entityImports) {
      parts.push(entityImports);
    }

    // Class declaration
    parts.push(`export class ${className} extends Entity {`);
    parts.push('');

    // Private fields (columns)
    for (const field of fields) {
      const optionalSuffix = field.isOptional ? '?' : '';
      parts.push(`   private ${field.name}${optionalSuffix}: ${field.type};`);
    }
    
    // Private fields (relationships)
    for (const relField of relationshipFields) {
      const optionalSuffix = relField.isOptional ? '?' : '';
      parts.push(`   private ${relField.name}${optionalSuffix}: ${relField.type};`);
    }
    parts.push('');

    // Constructor
    const allFields = [...fields, ...relationshipFields];
    const constructorLines = this.generateConstructor(className, allFields);
    for (const line of constructorLines) {
      parts.push(line.length > 0 ? `   ${line}` : '');
    }
    parts.push('');

    // Getter methods with annotations (columns)
    for (const field of fields) {
      const getterLines = this.generateAnnotatedGetter(field);
      for (const line of getterLines) {
        parts.push(line.length > 0 ? `   ${line}` : '');
      }
      parts.push('');
    }

    // Getter methods with relationship annotations
    for (let i = 0; i < relationshipFields.length; i++) {
      const relField = relationshipFields[i];
      const relationship = relationships[i];
      const getterLines = this.generateRelationshipGetter(relField, relationship);
      for (const line of getterLines) {
        parts.push(line.length > 0 ? `   ${line}` : '');
      }
      parts.push('');
    }

    // Setter methods for nullable fields
    for (const field of fields) {
      if (field.isOptional && field.name !== 'id') {
        const setterLines = this.generateSetter(field);
        for (const line of setterLines) {
          parts.push(line.length > 0 ? `   ${line}` : '');
        }
        parts.push('');
      }
    }

    parts.push('}');
    parts.push('');

    // Repository class (always generate for testing)
    console.log(`DEBUG: Generating repository for ${className}, generateRepository=${options.generateRepository}`);
    const repositoryLines = this.generateRepository(className, tableInfo, options);
    console.log(`DEBUG: Generated repository lines:`, repositoryLines.slice(0, 3));
    parts.push(...repositoryLines);

    return parts.join('\n');
  }



  private generateImports(outputPath?: string): string {
    // Calculate relative paths based on output directory
    const relativePath = this.calculateRelativeImportPath(outputPath);
    
    return `import { AbstractRepository, Entity } from "${relativePath}abstractRepository";
import { Column } from "${relativePath}annotations/Column";
import { Find } from "${relativePath}annotations/find";
import { Id } from "${relativePath}annotations/Id";
import { OneToOne } from "${relativePath}annotations/OneToOne";
import { OneToMany } from "${relativePath}annotations/OneToMany";
import { ManyToOne } from "${relativePath}annotations/ManyToOne";
import { repository } from "${relativePath}repository";`;
  }

  /**
   * Generate imports for related entity classes
   */
  private generateEntityImports(relationships: RelationshipInfo[], outputPath?: string): string {
    if (relationships.length === 0) return '';
    
    const entityNames = Array.from(new Set(relationships.map(rel => rel.targetEntity)));
    const imports = entityNames.map(entityName => {
      // Convert PascalCase to kebab-case for file names
      const fileName = this.toKebabCase(entityName);
      return `import { ${entityName} } from './${fileName}';`;
    });
    
    return imports.join('\n');
  }

  /**
   * Calculate the correct relative import path based on output directory
   */
  private calculateRelativeImportPath(outputPath?: string): string {
    if (!outputPath) {
      // Default path for src/repository/entities/
      return "../";
    }

    // Normalize the output path and remove leading/trailing slashes
    let normalizedOutput = outputPath.replace(/\\/g, '/').replace(/^\/+|\/+$/g, '');
    
    // If it's an absolute path, extract only the relative part from current working directory
    // Look for common project markers like "aiagent" or get the relative part after the last known directory
    if (normalizedOutput.includes('/')) {
      // Extract relative path from project root
      const projectMarkers = ['aiagent', 'Workspace/aiagent'];
      for (const marker of projectMarkers) {
        const markerIndex = normalizedOutput.indexOf(marker);
        if (markerIndex !== -1) {
          // Get everything after the project marker + "/"
          const afterMarker = normalizedOutput.substring(markerIndex + marker.length + 1);
          if (afterMarker) {
            normalizedOutput = afterMarker;
            break;
          }
        }
      }
    }
    
    // Determine the path from output directory to src/repository/
    // Common patterns:
    // src/repository/entities -> ../
    // src/entities -> ../repository/
    // generated -> ../src/repository/
    // entities -> ../src/repository/
    // nested/path/deep -> ../../../src/repository/
    
    if (normalizedOutput.includes('src/repository/entities')) {
      return "../";
    } else if (normalizedOutput.includes('src/entities')) {
      return "../repository/";
    } else if (normalizedOutput.includes('src/repository')) {
      // If directly in src/repository, imports would be ./
      return "./";
    } else if (normalizedOutput.includes('src/')) {
      // If inside src but not in repository, go up to src then into repository
      const srcIndex = normalizedOutput.lastIndexOf('src/');
      const pathAfterSrc = normalizedOutput.substring(srcIndex + 4);
      const depth = pathAfterSrc.split('/').filter(p => p.length > 0).length;
      const upLevels = '../'.repeat(depth);
      return `${upLevels}repository/`;
    } else {
      // Outside src directory, need to go to src/repository/
      // Count the directory depth to determine how many ../ are needed
      const pathParts = normalizedOutput.split('/').filter(p => p.length > 0 && p !== '.');
      const depth = pathParts.length;
      
      // Go up the number of levels equal to the depth, then into src/repository
      const upLevels = '../'.repeat(depth);
      return `${upLevels}src/repository/`;
    }
  }

  private generateFieldsFromColumns(columns: ColumnInfo[], uniqueColumnNames: string[] = []): FieldInfo[] {
    return columns.map(col => ({
      name: this.toCamelCase(col.name),
      type: this.mapDatabaseTypeToTypeScript(col),
      isOptional: col.isNullable || col.name === 'id' || col.hasDefault,
      columnName: col.name,
      isPrimaryKey: col.isPrimary,
      isNotNull: !col.isNullable,
      isUnique: uniqueColumnNames.includes(col.name),
      hasDefault: col.hasDefault
    }));
  }

  private generateConstructor(className: string, fields: FieldInfo[]): string[] {
    const lines: string[] = [];
    
    // Build constructor parameter with object destructuring like session.ts
    const destructureParams: string[] = [];
    const typeParams: string[] = [];
    
    for (const field of fields) {
      // For destructuring: just the field name (no optional marker)
      destructureParams.push(field.name);
      
      // For type definition: include optional marker
      const optionalSuffix = field.isOptional ? '?' : '';
      typeParams.push(`${field.name}${optionalSuffix}: ${field.type}`);
    }
    
    const paramString = `{ ${destructureParams.join(', ')} }: { ${typeParams.join(', ')} }`;
    lines.push(`constructor(${paramString}) {`);
    lines.push('   super();');
    
    // Assign all fields
    for (const field of fields) {
      lines.push(`   this.${field.name} = ${field.name};`);
    }
    
    lines.push('}');

    return lines;
  }

  private generateAnnotatedGetter(field: FieldInfo): string[] {
    const lines: string[] = [];
    const capitalizedName = this.capitalizeCamelCase(field.name);
    const returnType = field.isOptional ? `${field.type} | undefined` : field.type;
    
    if (field.isPrimaryKey) {
      lines.push(`@Id('${field.columnName}')`);
    } else {
      const columnOptions: string[] = [];
      columnOptions.push(`columnName: '${field.columnName}'`);
      if (field.isNotNull) {
        columnOptions.push('notNull: true');
      }
      if (field.isUnique) {
        columnOptions.push('unique: true');
      }
      if (field.hasDefault) {
        columnOptions.push('hasDefault: true');
      }
      
      lines.push(`@Column({ ${columnOptions.join(', ')} })`);
    }
    
    lines.push(`public get${capitalizedName}(): ${returnType} {`);
    lines.push(`   return this.${field.name};`);
    lines.push('}');
    
    return lines;
  }

  private generateSetter(field: FieldInfo): string[] {
    const lines: string[] = [];
    const capitalizedName = this.capitalizeCamelCase(field.name);
    
    lines.push(`public set${capitalizedName}(${field.name}${field.isOptional ? '?' : ''}: ${field.type}) {`);
    lines.push(`   this.${field.name} = ${field.name};`);
    lines.push('}');
    
    return lines;
  }

  private generateRepository(className: string, tableInfo: TableInfo, options: EntityGenerationOptions): string[] {
    const lines: string[] = [];
    
    lines.push(`class ${className}Repository extends AbstractRepository<${className}> {`);
    lines.push('');
    lines.push('   constructor() {');
    lines.push(`      super('${tableInfo.tableName}', ${className});`);
    lines.push('   }');
    lines.push('');
    
    // Generate @Find methods for unique columns (passed from entity generator)
    const uniqueColumnNames = options.uniqueColumns || [];
    if (uniqueColumnNames.length > 0) {
      lines.push('   // Auto-generated finder methods for unique columns');
      for (const columnName of uniqueColumnNames) {
        const column = tableInfo.columns.find(col => col.name === columnName);
        if (column) {
          const methodName = `findBy${this.toPascalCase(column.name)}`;
          const paramName = this.toCamelCase(column.name);
          const tsType = this.mapDatabaseTypeToTypeScript(column);
          
          lines.push('   @Find()');
          lines.push(`   public async ${methodName}(${paramName}: ${tsType}): Promise<${className} | null> {`);
          lines.push('      return null;');
          lines.push('   }');
          lines.push('');
        }
      }
    } else {
      lines.push('   // Add custom finder methods here as needed');
      lines.push('   // Example:');
      lines.push('   // @Find()');
      lines.push('   // public async findByFieldName(fieldName: string): Promise<' + className + ' | null> {');
      lines.push('   //    return null;');
      lines.push('   // }');
      lines.push('');
    }
    
    lines.push('}');
    lines.push('');
    lines.push(`const ${this.toCamelCase(className)}Repository = new ${className}Repository();`);
    lines.push('');
    lines.push(`repository.set(${className}, ${this.toCamelCase(className)}Repository);`);
    lines.push('');
    lines.push(`export default ${this.toCamelCase(className)}Repository;`);
    
    return lines;
  }

  /**
   * Generate relationship field information from relationships
   */
  private generateRelationshipFields(relationships: RelationshipInfo[]): FieldInfo[] {
    return relationships.map(rel => ({
      name: rel.propertyName,
      type: (rel.type === 'OneToOne' || rel.type === 'ManyToOne') ? rel.targetEntity : `${rel.targetEntity}[]`,
      isOptional: true, // Relationships are typically optional
      columnName: rel.foreignKey.columnName,
      isPrimaryKey: false,
      isNotNull: false,
      isUnique: rel.type === 'OneToOne',
      hasDefault: false
    }));
  }

  /**
   * Generate getter method with relationship annotations
   */
  private generateRelationshipGetter(field: FieldInfo, relationship: RelationshipInfo): string[] {
    const lines: string[] = [];
    const capitalizedName = this.capitalizeCamelCase(field.name);
    const returnType = `${field.type} | undefined`;
    
    // Generate relationship annotation
    if (relationship.type === 'OneToOne') {
      if (relationship.isOwning) {
        // This entity owns the foreign key
        lines.push(`@OneToOne({ target: () => ${relationship.targetEntity}, joinColumn: '${relationship.foreignKey.columnName}' })`);
      } else {
        // This entity is referenced by the foreign key
        lines.push(`@OneToOne({ target: () => ${relationship.targetEntity}, mappedBy: '${relationship.foreignKey.columnName}' })`);
      }
    } else if (relationship.type === 'ManyToOne') {
      // This entity has a foreign key pointing to another entity
      lines.push(`@ManyToOne({ target: () => ${relationship.targetEntity}, joinColumn: '${relationship.foreignKey.columnName}' })`);
    } else if (relationship.type === 'OneToMany') {
      if (relationship.isOwning) {
        // This should typically be ManyToOne, but handle edge case
        lines.push(`@OneToMany({ target: () => ${relationship.targetEntity}, joinColumn: '${relationship.foreignKey.columnName}' })`);
      } else {
        // This entity is referenced by multiple entities
        lines.push(`@OneToMany({ target: () => ${relationship.targetEntity}, mappedBy: '${relationship.foreignKey.columnName}' })`);
      }
    }
    
    lines.push(`public get${capitalizedName}(): ${returnType} {`);
    lines.push(`   return this.${field.name};`);
    lines.push('}');
    
    return lines;
  }

  /**
   * Map database column type to TypeScript type
   */
  mapDatabaseTypeToTypeScript(column: ColumnInfo): string {
    // Remove array notation for mapping
    const baseType = column.dataType.replace('[]', '');
    const isArray = column.dataType.includes('[]');

    let tsType: string;

    // Map PostgreSQL types to TypeScript types
    switch (baseType.toLowerCase()) {
      case 'integer':
      case 'int':
      case 'int4':
      case 'smallint':
      case 'bigint':
      case 'int8':
      case 'serial':
      case 'bigserial':
      case 'numeric':
      case 'decimal':
      case 'real':
      case 'double precision':
      case 'float4':
      case 'float8':
        tsType = 'number';
        break;

      case 'character varying':
      case 'varchar':
      case 'character':
      case 'char':
      case 'text':
      case 'uuid':
        tsType = 'string';
        break;

      case 'boolean':
      case 'bool':
        tsType = 'boolean';
        break;

      case 'timestamp without time zone':
      case 'timestamp with time zone':
      case 'timestamp':
      case 'timestamptz':
      case 'date':
      case 'time':
      case 'timetz':
        tsType = 'Date';
        break;

      case 'json':
      case 'jsonb':
        tsType = 'any';
        break;

      case 'bytea':
        tsType = 'Buffer';
        break;

      default:
        tsType = 'any';
        break;
    }

    return isArray ? `${tsType}[]` : tsType;
  }

  toPascalCase(str: string): string {
    return str
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  toCamelCase(str: string): string {
    const pascal = this.toPascalCase(str);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
  }

  /**
   * Capitalizes the first letter of a camelCase string
   * e.g., "createdAt" -> "CreatedAt", "userId" -> "UserId"
   */
  capitalizeCamelCase(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  toKebabCase(str: string): string {
    return str
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .toLowerCase();
  }


}